# Лабораторная работа №1

```
Выполнил: Филатов Фёдор Романович P3322

Вариант: 6, 25
```

## Проблема 6

### Описание

Сумма квадратов первых десяти натуральных чисел: `1^2 + 2^2 + ... + 10^2 = 385`.

Квадрат суммы первых десяти натуральных чисел: `(1 + 2 + ... + 10)^2 = 55^2 = 3025`.

Разница между двумя этими числами: `3025 - 385 = 2640`.

Найдите разницу между суммой квадратов и квадрата суммы первых ста натуральных чисел.

### Реализация

Решение было реализованно двумя разными способами:

1. Реализация на основе спец. синтаксиса для циклов.
2. Модульная реализация (генерация последовательности и свёртка).

#### Реализация на основе спец. синтаксиса для циклов

``` ./src/problem_6/loop.clj ```

Отдельно реализована функция для возведения в квадрат.
Главная функция реализует конструкцию loop и recur.
Для рекурсивной функции есть базовый случай, который останавливает цикл. Использование цикла позволяет компилятору оптимизировать код для рекурсии.

```clojure
 (defn square [n] (* n n))
 (defn sum_square_difference [n]
  (loop [a 1
         sum_of_the_squares 0
         square_of_the_sum 0]
    (if ( = a (+ 1 n))
      (- (square square_of_the_sum) sum_of_the_squares)
      (recur (inc a) (+ sum_of_the_squares (square a)) (+ square_of_the_sum a)))))
 ```


#### Модульная реализация 

``` ./src/problem_6/modular.clj ```

Создается последовательность длинны `n` с помощью `iterate` от `1`. Для первого случая все числа последовательности складываются и возводятся в квадрат.
Для второго слуачая все числа последовательнсти возводятся в квадрат, а потом складываются. Далее находится разница между двумя суммами.

```clojure
(defn square [n] (* n n))
(defn sum_square_difference [n]
  (let [data (take n (iterate inc 1))]
    (- (square (reduce + data)) (reduce + (map square data)))))
```

## Проблема 25

### Описание

Последовательность Фибоначчи выглядит следующим образом:
`F_n = F_{n - 1} + F_{n - 2}, где F_1 = 1 и F_2 = 1`.

Первые 12 элементов: `{1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144}`.

Двенадцатый элемент - это первый элемент, который содержит три цифр.

Найдите индекс первого числа в последовательнсти Фибоначчи, которое содержит 1000 цифр.

### Реализация

Решение было реализованно тремя разными способами:

1. Ленивые последовательности.
2. Рекурсия.
3. Хвостовая рекурсия.


#### Реализация на основе ленивых последовательностей

``` ./src/problem_25/lazy.clj ```

Отдельно реализована функция для подсчета цифр в числе и функция для подсчета чисел Фибоначчи.

В основной функции подсчитывается длина списка, который возвращает функция с числами Фибонначчи, далее прибавляется единица.
Так как список содежит все числа, которые меньше указанной длинны, а нужное нам число идет следующим, значит его индекс будет равен длине списка `+ 1`.

```clojure
(defn len [n] (count (str n)))
(defn fib
  ([] (concat [1M 1M] (fib 1M 1M)))
  ([a b]
   (let [n (+ a b)]
     (lazy-seq (cons n (fib b n))))))
(defn thousand-digit_fibonacci_number [length]
  (+ 1 (count (take-while #(< (len %) length) (fib)))))
 ```


#### Реализация на основе рекурсии

``` ./src/problem_25/recursion.clj ```

Отдельно реализована функция для подсчета цифр в числе.

```clojure
(defn len [n] (count (str n)))
(defn thousand-digit_fibonacci_number
  ([length] (thousand-digit_fibonacci_number 1M 1M length))
  ([a b length]
   (if (= (len (+ a b)) length)
     3
     (+ 1 (thousand-digit_fibonacci_number b (+ a b) length)))))
 ```


#### Реализация на основе хвостовой рекурсии

``` ./src/problem_25/tail.clj ```

Отдельно реализована функция для подсчета цифр в числе.

```clojure
(defn len [n] (count (str n)))
(defn thousand-digit_fibonacci_number
  ([length] (thousand-digit_fibonacci_number 1M 1M 3 length))
  ([a b index length]
   (if (= (len (+ a b)) length)
     index
     (recur b (+ a b) (inc index) length))))
 ```

## Вывод
В данной лабораторной работе я познакомился с основами языка Clojure, реализовал несколько способов
решения различных задач. Я смог освоить новый для меня синтаксис и стиль написание кода.
